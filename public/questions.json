{
    "questions": [
      {
        "id": 1,
        "title": "Two Sum",
        "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.",
        "examples": [
          {
            "input": "nums = [2,7,11,15], target = 9",
            "output": "[0,1]",
            "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
          },
          {
            "input": "nums = [3,2,4], target = 6",
            "output": "[1,2]"
          }
        ],
        "constraints": [
          "2 <= nums.length <= 10^4",
          "-10^9 <= nums[i] <= 10^9",
          "-10^9 <= target <= 10^9",
          "Only one valid answer exists."
        ],
        "starterCode": "function twoSum(nums, target) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 2,
        "title": "Valid Parentheses",
        "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
        "examples": [
          {
            "input": "s = \"()\"",
            "output": "true"
          },
          {
            "input": "s = \"()[]{}\"",
            "output": "true"
          },
          {
            "input": "s = \"(]\"",
            "output": "false"
          }
        ],
        "constraints": [
          "1 <= s.length <= 10^4",
          "s consists of parentheses only '()[]{}'."
        ],
        "starterCode": "function isValid(s) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 3,
        "title": "Reverse Linked List",
        "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
        "examples": [
          {
            "input": "head = [1,2,3,4,5]",
            "output": "[5,4,3,2,1]"
          },
          {
            "input": "head = [1,2]",
            "output": "[2,1]"
          },
          {
            "input": "head = []",
            "output": "[]"
          }
        ],
        "constraints": [
          "The number of nodes in the list is the range [0, 5000]",
          "-5000 <= Node.val <= 5000"
        ],
        "starterCode": "function reverseList(head) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 4,
        "title": "Maximum Subarray",
        "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
        "examples": [
          {
            "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
            "output": "6",
            "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
          },
          {
            "input": "nums = [1]",
            "output": "1"
          },
          {
            "input": "nums = [5,4,-1,7,8]",
            "output": "23"
          }
        ],
        "constraints": [
          "1 <= nums.length <= 10^5",
          "-10^4 <= nums[i] <= 10^4"
        ],
        "starterCode": "function maxSubArray(nums) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 5,
        "title": "Merge Two Sorted Lists",
        "description": "Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.",
        "examples": [
          {
            "input": "l1 = [1,2,4], l2 = [1,3,4]",
            "output": "[1,1,2,3,4,4]"
          },
          {
            "input": "l1 = [], l2 = []",
            "output": "[]"
          },
          {
            "input": "l1 = [], l2 = [0]",
            "output": "[0]"
          }
        ],
        "constraints": [
          "The number of nodes in both lists is in the range [0, 50]",
          "-100 <= Node.val <= 100",
          "Both l1 and l2 are sorted in non-decreasing order."
        ],
        "starterCode": "function mergeTwoLists(l1, l2) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 6,
        "title": "Binary Search",
        "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.",
        "examples": [
          {
            "input": "nums = [-1,0,3,5,9,12], target = 9",
            "output": "4",
            "explanation": "9 exists in nums and its index is 4"
          },
          {
            "input": "nums = [-1,0,3,5,9,12], target = 2",
            "output": "-1",
            "explanation": "2 does not exist in nums so return -1"
          }
        ],
        "constraints": [
          "1 <= nums.length <= 10^4",
          "-10^4 < nums[i], target < 10^4",
          "All the integers in nums are unique",
          "nums is sorted in ascending order"
        ],
        "starterCode": "function search(nums, target) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 7,
        "title": "Palindrome Number",
        "description": "Given an integer x, return true if x is palindrome integer. An integer is a palindrome when it reads the same backward as forward.",
        "examples": [
          {
            "input": "x = 121",
            "output": "true",
            "explanation": "121 reads as 121 from left to right and from right to left."
          },
          {
            "input": "x = -121",
            "output": "false",
            "explanation": "From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome."
          },
          {
            "input": "x = 10",
            "output": "false",
            "explanation": "Reads 01 from right to left. Therefore it is not a palindrome."
          }
        ],
        "constraints": [
          "-2^31 <= x <= 2^31 - 1"
        ],
        "starterCode": "function isPalindrome(x) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 8,
        "title": "Contains Duplicate",
        "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
        "examples": [
          {
            "input": "nums = [1,2,3,1]",
            "output": "true"
          },
          {
            "input": "nums = [1,2,3,4]",
            "output": "false"
          },
          {
            "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
            "output": "true"
          }
        ],
        "constraints": [
          "1 <= nums.length <= 10^5",
          "-10^9 <= nums[i] <= 10^9"
        ],
        "starterCode": "function containsDuplicate(nums) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 9,
        "title": "First Bad Version",
        "description": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.",
        "examples": [
          {
            "input": "n = 5, bad = 4",
            "output": "4",
            "explanation": "call isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version."
          },
          {
            "input": "n = 1, bad = 1",
            "output": "1"
          }
        ],
        "constraints": [
          "1 <= bad <= n <= 2^31 - 1"
        ],
        "starterCode": "function firstBadVersion(n) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 10,
        "title": "Climbing Stairs",
        "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
        "examples": [
          {
            "input": "n = 2",
            "output": "2",
            "explanation": "There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps"
          },
          {
            "input": "n = 3",
            "output": "3",
            "explanation": "There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
          }
        ],
        "constraints": [
          "1 <= n <= 45"
        ],
        "starterCode": "function climbStairs(n) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 11,
        "title": "Best Time to Buy and Sell Stock",
        "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
        "examples": [
          {
            "input": "prices = [7,1,5,3,6,4]",
            "output": "5",
            "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell."
          },
          {
            "input": "prices = [7,6,4,3,1]",
            "output": "0",
            "explanation": "In this case, no transactions are done and the max profit = 0."
          }
        ],
        "constraints": [
          "1 <= prices.length <= 10^5",
          "0 <= prices[i] <= 10^4"
        ],
        "starterCode": "function maxProfit(prices) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 12,
        "title": "Invert Binary Tree",
        "description": "Given the root of a binary tree, invert the tree, and return its root. To invert a binary tree, you need to swap every left node with its right node.",
        "examples": [
          {
            "input": "root = [4,2,7,1,3,6,9]",
            "output": "[4,7,2,9,6,3,1]"
          },
          {
            "input": "root = [2,1,3]",
            "output": "[2,3,1]"
          },
          {
            "input": "root = []",
            "output": "[]"
          }
        ],
        "constraints": [
          "The number of nodes in the tree is in the range [0, 100]",
          "-100 <= Node.val <= 100"
        ],
        "starterCode": "function invertTree(root) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 13,
        "title": "Longest Common Prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
        "examples": [
          {
            "input": "strs = [\"flower\",\"flow\",\"flight\"]",
            "output": "\"fl\""
          },
          {
            "input": "strs = [\"dog\",\"racecar\",\"car\"]",
            "output": "\"\"",
            "explanation": "There is no common prefix among the input strings."
          }
        ],
        "constraints": [
          "1 <= strs.length <= 200",
          "0 <= strs[i].length <= 200",
          "strs[i] consists of only lowercase English letters."
        ],
        "starterCode": "function longestCommonPrefix(strs) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 14,
        "title": "Symmetric Tree",
        "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
        "examples": [
          {
            "input": "root = [1,2,2,3,4,4,3]",
            "output": "true"
          },
          {
            "input": "root = [1,2,2,null,3,null,3]",
            "output": "false"
          }
        ],
        "constraints": [
          "The number of nodes in the tree is in the range [1, 1000]",
          "-100 <= Node.val <= 100"
        ],
        "starterCode": "function isSymmetric(root) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 15,
        "title": "Majority Element",
        "description": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.",
        "examples": [
          {
            "input": "nums = [3,2,3]",
            "output": "3"
          },
          {
            "input": "nums = [2,2,1,1,1,2,2]",
            "output": "2"
          }
        ],
        "constraints": [
          "n == nums.length",
          "1 <= n <= 5 * 10^4",
          "-10^9 <= nums[i] <= 10^9"
        ],
        "starterCode": "function majorityElement(nums) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 16,
        "title": "Convert Sorted Array to Binary Search Tree",
        "description": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
        "examples": [
          {
            "input": "nums = [-10,-3,0,5,9]",
            "output": "[0,-3,9,-10,null,5]",
            "explanation": "One possible answer is [0,-3,9,-10,null,5], which represents the height balanced BST."
          },
          {
            "input": "nums = [1,3]",
            "output": "[3,1]"
          }
        ],
        "constraints": [
          "1 <= nums.length <= 10^4",
          "-10^4 <= nums[i] <= 10^4",
          "nums is sorted in a strictly increasing order."
        ],
        "starterCode": "function sortedArrayToBST(nums) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 17,
        "title": "Linked List Cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Return true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
          {
            "input": "head = [3,2,0,-4], pos = 1",
            "output": "true",
            "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
          },
          {
            "input": "head = [1,2], pos = 0",
            "output": "true",
            "explanation": "There is a cycle in the linked list, where the tail connects to the 0th node."
          },
          {
            "input": "head = [1], pos = -1",
            "output": "false",
            "explanation": "There is no cycle in the linked list."
          }
        ],
        "constraints": [
          "The number of the nodes in the list is in the range [0, 10^4]",
          "-10^5 <= Node.val <= 10^5",
          "pos is -1 or a valid index in the linked-list."
        ],
        "starterCode": "function hasCycle(head) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 18,
        "title": "Implement Queue using Stacks",
        "description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class:",
        "examples": [
          {
            "input": "MyQueue myQueue = new MyQueue();\nmyQueue.push(1);\nmyQueue.push(2);\nmyQueue.peek();\nmyQueue.pop();\nmyQueue.empty();",
            "output": "[null, null, null, 1, 1, false]"
          }
        ],
        "constraints": [
          "1 <= x <= 9",
          "At most 100 calls will be made to push, pop, peek, and empty.",
          "All the calls to pop and peek are valid."
        ],
        "starterCode": "class MyQueue {\n  constructor() {\n    // Your implementation\n  }\n  \n  push(x) {\n    // Your implementation\n  }\n  \n  pop() {\n    // Your implementation\n  }\n  \n  peek() {\n    // Your implementation\n  }\n  \n  empty() {\n    // Your implementation\n  }\n}"
      },
      {
        "id": 19,
        "title": "Find All Numbers Disappeared in an Array",
        "description": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.",
        "examples": [
          {
            "input": "nums = [4,3,2,7,8,2,3,1]",
            "output": "[5,6]"
          },
          {
            "input": "nums = [1,1]",
            "output": "[2]"
          }
        ],
        "constraints": [
          "n == nums.length",
          "1 <= n <= 10^5",
          "1 <= nums[i] <= n"
        ],
        "starterCode": "function findDisappearedNumbers(nums) {\n  // Your implementation\n  \n}"
      },
      {
        "id": 20,
        "title": "Move Zeroes",
        "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.",
        "examples": [
          {
            "input": "nums = [0,1,0,3,12]",
            "output": "[1,3,12,0,0]"
          },
          {
            "input": "nums = [0]",
            "output": "[0]"
          }
        ],
        "constraints": [
          "1 <= nums.length <= 10^4",
          "-2^31 <= nums[i] <= 2^31 - 1"
        ],
        "starterCode": "function moveZeroes(nums) {\n  // Your implementation\n  \n}"
      }
    ]
  }